##-----------------------------
## Parses LogMessage APP events
##-----------------------------

filter {
    if [@type] == "LogMessage" and [@source][type] == "app" {

        mutate {
            add_tag => [ "app" ]
        }

        # Parse application logs based on msg format.
        # Marks unknown format with [unknown_msg_format] tag.

        ## ---- Format 1: JSON
        if [@message] =~ /^\s*{".*}\s*$/ {                              # if it looks like JSON
            json {
              source => "@message"
              target => "app"
              add_tag => [ "json" ]
              tag_on_failure => [ "no_json" ]
            }
            if ("json" in [tags]) {
                # concat message and exception
                if [app][exception] {
                    mutate {
                      replace => { "@level" => "ERROR" }
                    }
                }
                # @level
                if [app][level] {
                    mutate {
                      replace => { "@level" => "%{[app][level]}" }
                    }
                }
                if [app][log_level] {
                    translate {
                      field => "[app][log_level]"
                      dictionary => [ "0", "DEBUG", "1", "INFO", "2", "ERROR", "3", "FATAL" ]
                      destination => "@level"
                      override => true
                      fallback => "%{[app][log_level]}"
                    }
                }
                # set @timestamp from event's timestamp if it is passed
                if [app][timestamp] or [app][start_timestamp] {
                    if [app][start_timestamp] {
                        mutate {
                          add_field => { "event_timestamp" => "%{[app][start_timestamp]}" }
                          convert => { "event_timestamp" => "string" }
                          gsub => ["event_timestamp", "\d{6}$", ""]
                        }
                    } else {
                        mutate {
                          add_field => { "event_timestamp" => "%{[app][timestamp]}" }
                          convert => { "event_timestamp" => "string" }
                          gsub => ["event_timestamp", "\d{6}$", ""]
                        }
                    }
                    date {
                      match => [ "event_timestamp", "UNIX_MS" ]
                      remove_field => [ "event_timestamp" ]
                    }
                } else if [app][time] {
                    # if event's timestamp is not passed then we set @timestamp = event shipping time from firehose-to-syslog
                    date {
                      match => [ "[app][time]", "ISO8601"]
                    }
                }
            }

        ## ---- Format 2: "[CONTAINER] .." (Tomcat logs)
        } else if [@message] =~ /^\s*\[CONTAINER\]/ {
            # Tomcat specific parsing (in accordance with https://github.com/cloudfoundry/java-buildpack-support/blob/master/tomcat-logging-support/src/main/java/com/gopivotal/cloudfoundry/tomcat/logging/CloudFoundryFormatter.java)
            grok {
              match => { "@message" => "(?<app_logger>\[CONTAINER\]%{SPACE}%{NOTSPACE})%{SPACE}%{LOGLEVEL:@level}%{SPACE}%{GREEDYDATA:@message}" }
              overwrite => [ "@message", "@level" ]
              add_tag => [ "tomcat" ]
              tag_on_failure => [ "no_tomcat" ]
            }
            mutate {
              rename => { "app_logger" => "[app][logger]" }
            }

        ## ---- Format 3: Logback status logs
        } else {
            grok {
              match => { "@message" => "%{TIME} \|\-%{LOGLEVEL:@level} in %{NOTSPACE:[app][logger]} - %{GREEDYDATA:@message}" }
              overwrite => [ "@message", "@level" ]
              tag_on_failure => [ "unknown" ]
            }
        }
    }
}

